#### 第四周编程解析 ####
**T1**：这道题直接DFS有超时的可能（$f[15]=9694845$，搜索空间会非常大），因此必须要采用递推（也可以说是动态规划）的方式解决，现在设$f[i][j]$表示已经有$i$个元素在栈中，还有$j$个元素尚未入栈，则问题即求解$f[0][n]$。当$j=0$时，显然只有一种可能，就是将栈中元素逐个弹出，因此$f[i][0]=1$（边界条件）；当$i,j \neq 0$时，从该状态可以推出两种状态，一种是已经有$(i-1)$个元素在栈中，还有$j$个元素尚未入栈（此时只要让1个元素出栈即可，栈中元素个数-1，未入栈元素个数+0），另一种是已经有$(i+1)$个元素在栈中，还有$(j-1)$个元素尚未入栈（此时将1个尚未入栈的元素加入栈中，则栈中元素个数+1，未入栈元素个数-1），相应的，状态转移方程为$f[i][j]=f[i-1][j]+f[i+1][j-1] \; (1 \leq j \leq n,1 \leq i \leq n-j)$；当$i=0$时，此时栈为空，无法弹出元素，因此只能让元素入栈，相应的，状态转移方程为$f[i][j]=f[i+1][j-1] \; (1 \leq j \leq n,i=0)$，由此，我们即可递推出答案。

当然，我们不满足于这样的结果（空间开销太大，时间复杂度为$O(n^2)$），所以我们换一种思路，考虑到当元素总数为$n$，且已经有$(i-1)$个元素在栈中时，显然前$(i-1)$个元素的合法入栈-出栈序列有$f[i-1]$种；然后让第$i$个元素进入栈中，再出栈；最后让剩余的$(n-i)$个入栈，而这$(n-i)$个元素的合法入栈-出栈序列有$f[n-i]$种，因此$f[n]=\sum\limits_{i=1}^{n} f[i-1]f[n-i]$，这样解即可让空间开销大大减小，但直接计算的时间复杂度仍为$O(n^2)$。注意到该式恰恰是Catalan数的递推形式，因此有$f[n]=\frac{4n-2}{n+1} f[n-1]$，这样时间复杂度就变为$O(n)$（当然我没写$O(n)$的算法）

**T2**：这道题是中缀表达式的计算，巨坑无比。主要注意的点有：（1）本题读入时有空格，因此只能用getchar()一个个字符读过去，以及注意换行符在不同操作系统的定义；（2）判定数值与算符，此处由于用空格分隔，因此可以用sscanf进行读取，如果第一位为数字，或第一位为负号，第二位为数字，则转换成数值，扔进数值栈；如果是左括号，直接扔进算符栈；如果是右括号，则持续弹出算符栈顶，并计算数值栈顶和栈顶下一个元素的运算结果（注意数值的先后位置！），直到算符栈顶遇到左括号为止，然后将左括号弹出；如果是四则运算+乘方算符，在算符栈空的情况下直接入栈，在算符栈非空的情况下，比较当前算符和算符栈顶算符的优先级，若当前算符优先级高，则入栈，若当前算符优先级低，则持续弹出算符栈顶，进行计算，直到当前算符优先级高于算符栈顶算符的优先级为止，然后让当前算符入栈；（3）算符优先级的判定：按优先级从小到大排序：左括号<加减<乘除<乘方；（4）当表达式元素全部入栈后，计算没有结束，还要将算符栈逐个弹出，进行计算，直到算符栈为空，这时数值栈应该只剩一个元素，即最后的计算结果。

