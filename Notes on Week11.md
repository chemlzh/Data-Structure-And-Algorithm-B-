#### 第十一周编程解析 ####
**T1**：这个学期最磨人的题目之一，虽然是对每对点求最短路，但是有如下坑点：（1）两个点之间的路径不止一条，若采用Floyd算法（相应的图用邻接矩阵表示），则每次添加边时要取最短的那一条；若采用Dijkstra算法或SPFA（相应的图用邻接表表示），虽然在计算最短路径时无影响，但在输出最短路径时，仍需要用辅助的存储最短边的邻接矩阵（或字典）；（2）若采用Floyd算法，则Path矩阵要用二维表示，即Path[i][j]表示从i到j的最短路径中i的下一个节点，输出时采用递推；若采用Dijkstra算法或SPFA，则Path矩阵只需要一维表示，即Path[i]表示从s到i的最短路径中i的前一个节点，输出时采用栈以消除递归。（后记：这道题Dijkstra真的太逊，甚至不如Floyd，倒是SPFA效果拔群，毕竟这道题属于稀疏图情形，SPFA当然快很多）
**T2**：这道题是最小生成树的典型（模板）题，也没有很坑的要点，直接手打Kruskal算法即可。