#### 第五周编程解析 ####
**T1**：此题是让我们实现一个弱化版的双端队列，最初的思路为使用动态数组存储，用head表示队列头位置（头指针），len表示队列长度，则head+len表示队列尾位置（尾指针），如果尾指针碰到数组上界，就创建一个扩大后的数组，并将原队列的元素复制到新数组中（有点像STL的\<vector>）；后来结合循环队列的思路进行重写，如果尾指针碰到数组上界，先循环至数组下界，然后继续存储，直到len恰好等于数组长度，此时创建一个扩大后的数组，并将原队列的元素复制到新数组中。
以下是自编的T1样例，供查错用，也可对其进行进一步修改，以检测可能的错误：
1
22
1 1
1 2
1 3
1 4
1 5
2 0
2 0
1 6
1 7
1 8
1 9
1 10
2 1
2 1
2 1
2 1
1 11
1 12
1 13
1 14
1 15
1 16
对应的输出为：
3 4 5 6 11 12 13 14 15 16

**T2**：此题是让我们读入一个二叉树，读入的每一行具有形如"---X"的形式，其中"-"的个数代表节点所在的层次，而"X"为字母或星号，其中星号代表左子树不存在，字母代表具体的节点；读入数据以根节点->左子树->右子树的形式给出。因此，我们可以根据该性质**递归**建立二叉树，即先建立根节点；如果左子树非空，就递归建立左子树，若左子树为空（遇到带星号行），则设置一个标记（如记flag=1），这样读入下一行时，由数据的性质可知，此时建立的必为右子树；最后递归建立右子树（如遇到flag=1或左子树非空），此时要利用之前记录的父亲节点father，返回至待加入节点的上一层，然后建立右子树，同时消除标记（如记flag=0）。之后的先序、后序、中序遍历就非常简单了。
有趣的是，可以将带有具体节点参数的先序、后序、中序遍历写成结构体的方法，然后重载一个不带具体节点参数的先序、后序、中序遍历，重载的遍历直接以this为参数，调用带有具体节点参数的先序、后序、中序遍历。（终于不再写C with STL了，函数重载真香）